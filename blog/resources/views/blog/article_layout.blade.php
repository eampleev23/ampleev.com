@extends('layouts.app')

@section('title', "Как заставить микросервисы общаться?")
@section('description', 'Описание для SEO')
@section('page_url', route('blog.show_article', 'praktika_primenenia_burn_down_charts_v_kontekste_safe_i_scrum'))
@section('main_image_path', env('APP_URL').'/assets/img/article-5_my.jpg')

@section('custom_css')
    @parent
    <link href="assets/css/custom.css" rel="stylesheet" type="text/css" media="all"/>
    <link href="assets/css/custiom_article.css" rel="stylesheet" type="text/css" media="all"/>
    <!-- here we are-->
@endsection

@section('sidebar')
    @parent
@endsection

@section('content')
    @include('layouts.navbar_white')

    <div class="article-progress" data-sticky="below-nav">
        <progress class="reading-position" value="0"></progress>
        <div class="article-progress-wrapper">
            <div class="container">
                <div class="row">
                    <div class="col py-2">
                        <div class="d-flex justify-content-between align-items-center">
                            <div class="d-flex">
                                <div class="text-small text-muted mr-1">Читаете:</div>
                                <div class="text-small">Как заставить микросервисы общаться?</div>
                            </div>
                            <div class="d-flex align-items-center">
                                <span class="text-small text-muted">Поделиться:</span>
                                <div class="d-flex ml-1">
                                    <a href="{{$article->tweetHrefGenerate()}}"
                                       class="mx-1 btn btn-sm btn-round btn-primary">
                                        <img class="icon" src="assets/img/icons/social/twitter.svg"
                                             alt="twitter social icon" data-inject-svg/>
                                    </a>
                                    <a href="https://www.facebook.com/sharer/sharer.php?u={{route('blog.show_article', $article->text_url)}}&display=popup"
                                       class="mx-1 btn btn-sm btn-round btn-primary">
                                        <img class="icon" src="assets/img/icons/social/facebook.svg"
                                             alt="facebook social icon" data-inject-svg/>
                                    </a>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <section class="pb-0 pb-5">
        <div class="container">
            <div class="row justify-content-center">
                <div class="col-lg-10 col-xl-8">
                    <div class="d-flex justify-content-between align-items-center mb-3">
                        <nav aria-label="breadcrumb">
                            <ol class="breadcrumb">
                                <li class="breadcrumb-item">
                                    <a href="{{route('blog.home')}}">Блог</a>
                                </li>
                                <li class="breadcrumb-item">
                                    Development
                                </li>
                            </ol>
                        </nav>
                        <span class="badge bg-primary-alt text-primary">
                <img class="icon bg-primary" src="assets/my_svg/Eye_view_views_enable_watch_1886932.svg"
                     alt="heart interface icon"
                     data-inject-svg/>{{$article->views_count}}</span>
                    </div>
                    <h1>Как заставить микросервисы общаться? Часть 1.</h1>
                    <div class="d-flex align-items-center">
                        <a href="#">
                            <img src="{{env('APP_URL').$article->user->avatar_path}}" alt="Avatar" class="avatar mr-2">
                        </a>
                        <div>
                            <div>Автор статьи: <a href="#">{{$article->user->name}}</a>
                            </div>
                            <div class="text-small text-muted">{{$article->get_nice_time_created()}}</div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </section>

    <section class="p-0" data-reading-position>
        <div class="container">
            <div class="row justify-content-center position-relative">
                <div class="col-lg-10 col-xl-8">
                    <div class="popover-image"><img src="/assets/img/microservices_p2.jpg" alt="Image"
                                                    class="rounded border shadow-lg"></div>
                </div>
            </div>
            <div class="row justify-content-center">
                <div class="col-xl-7 col-lg-8 col-md-10">
                    <article class="article"><p class="lead"> Я практически уверен, что все хотят создавать легко
                            масштабируемые приложения, верно? А кто нет, все хотят. Если это так, вы, должно быть,
                            сталкивались со словами "Cloud Native". Этот подход похож на ангела, который, кажется, что
                            может решить большинство проблем связанных с масштабированием приложения. </p>
                        <blockquote class="bg-primary-alt">
                            <div class="h7 mb-2">Cloud Native - это подход, используемый при разработке приложений,
                                который позволяет им (приложениям) соответствовать следующим критериям: быть
                                эксплуатируемыми(т.е. ими можно пользоваться, их можно менять внешними инструиментами),
                                быть наблюдаемыми(т.е. можно с помощью какого-либо инструмента узнать текущее состояние
                                приложение и его производительность), быть эластичными(т.е. они могут изменяться в
                                размерах в рамках ресурсов и в зависимости от нагрузки), быть отказоустойчивыми(их можно
                                быстро восстановить после падения), быть динамичными(конфигурируемыми, деплой, в общем,
                                к нему должна быть возможность применить практики DevOps).
                            </div>
                        </blockquote>
                        <p class="lead"> Да, вы поняли это корректно: это именно <strong>подход</strong>. Не фреймворк.
                            Не пошаговая инструкция. И, как следствие, существуют миллионы таких Cloud Native-подходов
                            чтобы достичь этого вожделенного эффекта <a href="#" data-toggle="tooltip"
                                                                        data-placement="top" title=""
                                                                        data-original-title="в индуизме и джайнизме — освобождение из круговорота рождений и смертей (сансары) и всех страданий и ограничений материального существования.">&#171;Мокша&#187;</a>.
                        </p>
                        <p class="lead"> Один из ключевых принципов Cloud Native - это разделение приложения на
                            микросервисы. <strong>Микросервисы представляют собой крошечные (иногда не особо)
                                программные модули, которые могут работать независимо друг от друга.</strong> Они могут
                            иметь зависимости от других микросервисов или даже от базы данных, но зависимость должна
                            быть слабой - т.е. каждый микросервис если он и имеет зависимость от другого, должен быть
                            готов к тому, что другой перестанет существовать. Микросервисы взаимодействуют между собой
                            посредством &#171;общения&#187; - т.е. посредством диалога между собой - отправления
                            запросов и получения ответов.</p>
                        <p class="lead"> Это означает, что каждый микросервис находится в отдельном репозитории и может
                            быть обновлен независимо от других. Для DevOps-разработчиков также есть возможность
                            организовывать непрерывную доставку для микросервиса не зависимо от других
                            микросервисов. </p>
                        <p class="lead"> И это приводит нас к самому важному вопросу. </p>
                        <h5>Как заставить микросервисы общаться?</h5>
                        <p class="lead"> Даже не касаясь сложности соблюдения <a href="#" data-toggle="tooltip"
                                                                                 data-placement="right" title=""
                                                                                 data-original-title="Конструктивная характеристика, которая позволяет системе принимать ввод, предназначенный для более поздней версии самой себя">восходящей
                                совместимости</a> API для микросервисов, просто заставить их общаться не так просто как
                            может показаться на первый взгляд. Есть несколько параметров, которые необходимо учитывать.
                            Это <strong>пропускная способность</strong>, <strong>задержка</strong> и <strong>масштабируемость</strong>.
                        </p>
                        <p class="lead">В настоящее время существует множество классификаций способов общения между
                            микросервисами.
                            <mark>Синхронный (блокирующий) и асинхронный (неблокирующий) используются довольно
                                часто, но я предполагаю, что это в основном характеристики языка программирования.
                            </mark>
                            Я также
                            планирую не заострять внимание на режимах "дуплекс" или "полудуплекс", т.к. сейчас очень
                            легко использовать один или даже оба в большинстве облачных архитектур.
                        </p>
                        <p class="lead">Итак, давайте погрузимся в детали.</p>
                        <h2>Архитектура без брокера</h2>
                        <br/>
                        <div class="popover-image"><img src="/assets/img/microservices_p2.jpg" alt="Image"
                                                        class="rounded border shadow-lg"></div>
                        <br/> <br/>
                        <p class="lead"><strong>Что на изображении:</strong> здесь мы заставляем наши микросервисы
                            <strong>общаться напрямую друг с другом</strong>. Вы можете использовать HTTP для
                            традиционного запроса-ответа или использовать веб-сокеты (или HTTP2) для потоковой передачи.
                        </p>

                        <p class="lead">Между двумя и более микросервисами нет абсолютно никаких промежуточных узлов
                            (кроме маршрутизаторов и балансировщиков нагрузки). Вы можете подключиться к любому
                            микросервису напрямую, при условии, что вы знаете их адрес службы и используемый ими API.
                        </p>

                        <p class="lead">Звучит довольно просто, верно? Это в значительной степени так. Есть
                            замечательные протоколы, такие как GRPC, чтобы сделать жизнь намного проще.
                        </p>
                        <h6>Плюсы:</h6>
                        <ul>
                            <li>Низкая задержка: этот метод имеет минимально возможную задержку. Здесь нет посредников.
                                Это быстро. Ограничения могут быть в основном из-за плохой реализации API. Но опять же,
                                такие инструменты как GRPC, обеспечивают максимальную производительность на уровне API
                            </li>

                            <li>Простота реализации: архитектуру без посредников легко визуализировать и реализовать.
                                Это делает жизнь намного проще и мир становится счастливее.
                            </li>

                            <li>
                                Простая отладка: этот метод довольно прост в отладке, особенно по сравнению со
                                следующим, о котором
                                я собираюсь рассказать. Отладка или отслеживание ошибок - это очень важная тема в
                                распределенных системах. Это становится еще более важным, когда вы релизитесь несколько
                                раз в день.
                            </li>
                            <li>
                                Высокая пропускная способность: в этом методе больше циклов CPU фактически расходуется
                                на выполнение работы, а не на маршрутизацию. Сейчас это может быть не так очевидно, но
                                архитектура с брокером продемонстрирует это более явно. Неудивительно, что большинство
                                API баз данных
                                на самом деле используют дизайн без посредников.
                            </li>
                        </ul>

                        <h6>Минусы:</h6>
                        <ul>
                            <li>
                                Безопасность данных: В такой конструкции обнаружение сервиса имеет первостепенное
                                значение. Механизм обнаружения сервисов должен быть достаточно гибким и реагирующим,
                                чтобы
                                отражать последнее состояние кластера.
                            </li>
                            <li>
                                Много ресурсов простаивает: представьте, если бы все микросервисы общались друг с
                                другом. При этом было бы достаточно много соединений. В данной схеме этого нет, а значит
                                большое количество времени микросервисы простаивают. В
                                результате много ресурсов тратится впустую из-за этого.
                            </li>
                            <li>
                                Много ресурсов простаивает: представьте, если бы все микросервисы общались друг с
                                другом. При этом было бы достаточно много соединений. В данной схеме этого нет, а значит
                                большое количество времени микросервисы простаивают. В
                                результате много ресурсов тратится впустую из-за этого.
                            </li>
                            <li>
                                Взаимозависимость: по своей природе конструкции без посредников тесно связаны.
                                Представьте, что у вас есть микросервис для обработки онлайн-платежей. Теперь вы хотите,
                                чтобы другой микросервис в режиме реального времени обновлял количество платежей,
                                совершаемых за минуту. Это потребует от вас внесения изменений в несколько
                                микросервисов, что нежелательно.
                            </li>
                        </ul>
                        <p class="lead">
                            Во многих случаях архитектура без брокера просто не работает. Часто могут появиться
                            требования, когда необходимо чтобы на одно событие реагировали несколько микросервисов. В
                            этом случае как раз появляется необходимость в брокере.
                        </p>

                        <p class="lead">На этом я завершаю первую часть статьи. Во второй части продолжу.</p>

                        <h2>Архитектура с брокером</h2>
                        <br/>
                        <div class="popover-image"><img src="/assets/img/microservices_p3.jpg" alt="Image"
                                                        class="rounded border shadow-lg"></div>
                        <br/> <br/>
                        <p class="lead"><strong>Что на изображении:</strong> В этой архитектуре все общение между
                            микросервисами
                            происходит через посредников - группу брокеров. Брокеры - это серверные программы,
                            использующие
                            некоторые собственные алгоритмы маршрутизации.
                        </p>
                        <p class="lead">Каждый микросервис подключается к брокеру. Все сервисы могут получать и
                            отправлять сообщения через одно соединение. Микросервис, отправляющий сообщения, называется
                            <strong>издателем</strong>, а получатель - <strong>подписчиком</strong>. Сообщения
                            публикуются со специальной "темой".
                            Подписчик получает сообщения, на которые он подписан.</p>

                        <h6>Плюсы:</h6>
                        <ul>
                            <li>
                                Балансировка нагрузки: большинство брокеров поддерживают балансировку нагрузки из
                                коробки. Это делает общую архитектуру более простой и легко масштабируемой. Некоторые
                                брокеры (например, RabbitMQ) имеют встроенные повторы и многое другое для повышения
                                надежности канала связи.
                            </li>
                            <li>
                                Безопасность данных: Конкретные сервисы не доступны пользователям при использовании
                                серверной части
                                обмена сообщениями. Все микросервисы выступают в роли клиентов. Единственный сервис,
                                который может быть обнаружен, - это брокер сообщений.
                            </li>
                            <li>
                                Fan In и Fan Out: серверная часть обмена сообщениями облегчает распределение рабочей
                                нагрузки и агрегирование результатов. Самое приятное то, что добавление рабочих
                                микросервисов может быть выполнено прозрачно без необходимости обновления других
                                микросервисов.
                            </li>
                            <li>
                                Потоковое проектирование: Такой подход также порождает концепцию потоков. Каждая тема по
                                сути является потоком сообщений. Любой подписчик может подключиться к этим потокам по
                                мере необходимости. Возможности моделирования системного дизайна с использованием
                                потоков безграничны.
                            </li>
                        </ul>
                        <h6>Минусы:</h6>
                        <ul>
                            <li>
                                Масштабирование брокеров. Несмотря на то, что преимущества поразительны, масштабирование
                                самих брокеров становится проблемой для сильно распределенных систем. Это просто еще
                                одна вещь, которую нужно поддерживать вместе с вашими микросервисами.
                            </li>
                            <li>
                                Более высокая задержка: количество прыжков в шине сообщений увеличивает общую задержку.
                                Это особенно верно для случая использования, подобного RPC. В критически важных
                                приложениях это может быть непреодалимым препядствием.
                            </li>
                            <li>
                                Более высокое расходование ресурсов. Для работы брокерам необходимы ресурсы CPU, памяти
                                и хранилища. Эти ресурсы могли бы быть использованы для запуска других микросервисов.
                                Накладные расходы, связанные с архитектурой брокера, могут быть нерентабельными для
                                небольшого кластера.
                            </li>
                        </ul>
                        <p class="lead">
                            Недостаточно просто знать преимущества и недостатки различных архитектур. Важно понимать,
                            что выбор архитектуры сильно зависит от задачи, которую ставит перед собой приложение.
                        </p>
                        <p class="lead">
                            Вы всегда должны по умолчанию использовать архитектуру без брокера. Сделайте переключение,
                            если
                            вам нужна гибкость потоков или вам нужно использовать семантику pub-sub шины сообщений. Если
                            вы начинаете с нуля, имеет смысл начать с дизайна без брокера, а затем переключиться, когда
                            появится такая необходимость.
                        </p>
                        <p class="lead">
                            Нет необходимости выбирать конкретную архитектуру для приложения. Вы можете использовать
                            обе. Для нашего инструмента
                            мы используем архитектуру брокера для реализации вызовов RPC. Связь с нашим уровнем базы
                            данных
                            осуществляется без брокера, чтобы обеспечить более низкие задержки.
                        </p>

                        <h2>Заключение</h2>

                        <p class="lead">
                            Использование правильного подхода к построению микросервисов важно. Выбор способа общения
                            является
                            фундаментальным решением, которое необходимо принимать с большой осторожностью.
                        </p>

                        <p class="lead">Есть разные варианты реализаций для обоих подходов к архитектуре. Придерживаться
                            устоявшейся основы почти
                            всегда имеет больше смысла, чем создавать что-то с нуля. Чаще всего есть вариант решения без
                            смены парадигмы. Для
                            брокеров сообщений у вас есть RabbitMQ, Nats, Kafka и т.д., И каждый из них создан для
                            определенной семантики обмена сообщениями.</p>

                        <p class="lead">
                            Еще один замечательный способ - использовать Backend как сервис, такой как Space Cloud,
                            например.
                            Space Cloud автоматизирует весь бэкэнд, поэтому вы сможете сосредоточиться на бизнес-логике,
                            а не на облачной архитектуре.
                        </p>

                        <p class="lead">
                            <em>Помогла ли вам эта статья? Как сделать так, чтобы ваши приложения были облачными?
                                Поделитесь
                                своим опытом в комментариях.</em>
                        </p>

                    </article>
                </div>
            </div>
        </div>
    </section>

    <section class="has-divider">
        <div class="container pt-3">
            <div class="row justify-content-center">
                <div class="col-xl-7 col-lg-8 col-md-10">

                    <hr>
                    @include('blog.article.social_sharing')
                    @include('blog.article.answer_form')
                    <hr id="add_comment">
                    @include('blog.article.add_comment')

                </div>
            </div>
        </div>
        <div class="divider">
            <img class="bg-primary-alt" src="assets/img/dividers/divider-1.svg" alt="divider graphic" data-inject-svg/>
        </div>
    </section>

    @include('blog.article.related_stories')
    @include('blog.articles.emailing_list_footer')

@endsection

@section('pageScript')
    @parent
@endsection